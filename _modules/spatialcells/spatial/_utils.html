<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spatialcells.spatial._utils &#8212; SpatialCells 0.9.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script src="../../../_static/documentation_options.js?v=61b282d3"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for spatialcells.spatial._utils</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">_bfsGetShortestRing</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">,</span> <span class="n">start_point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of edges, return the shortest ring starting from start_point.</span>
<span class="sd">    Helper function for `_getOrderedEdgeComponents`</span>

<span class="sd">    :param edge_dict: a dict of edges. key is a point; value = set(its neighbors)</span>
<span class="sd">    :param start_point: the starting point of the ring</span>
<span class="sd">    :returns: a list of points representing the shortest ring</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bfs_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_point</span><span class="p">,</span> <span class="p">[</span><span class="n">start_point</span><span class="p">])]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bfs_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cur_point</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">bfs_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cur_point</span> <span class="o">==</span> <span class="n">start_point</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># found ring</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">[</span><span class="n">cur_point</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span> <span class="ow">or</span> <span class="p">(</span><span class="n">neighbor</span> <span class="o">==</span> <span class="n">start_point</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">bfs_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">]))</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Open ring found&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getOrderedEdgeComponents</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of edges, return a list of ordered edge components</span>
<span class="sd">    Helper function for `getAlphaShapes`</span>

<span class="sd">    :param edges: np.array of shape (n,2) for n edges.</span>
<span class="sd">    :returns: a list of ordered edge components. Each component </span>
<span class="sd">        is a np.array of shape (m,2) for m edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># key is a point; value = set(its neighbors)</span>
    <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">edge_dict</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">edge_dict</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">edge_dict</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="n">_pruneTouchingComponents</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">)</span>
    <span class="n">cur_point</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">))</span>
    <span class="n">ordered_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">not_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">next_point</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">[</span><span class="n">cur_point</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">not_visited</span><span class="p">:</span>
                <span class="n">edge_dict</span><span class="p">[</span><span class="n">cur_point</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="n">edge_dict</span><span class="p">[</span><span class="n">point</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cur_point</span><span class="p">)</span>
                <span class="n">next_point</span> <span class="o">=</span> <span class="n">point</span>
                <span class="n">ordered_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_point</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">cur_point</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">not_visited</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cur_point</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">next_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_visited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">cur_point</span><span class="p">)</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ordered_edges</span><span class="p">))</span>
            <span class="n">ordered_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">next_point</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">not_visited</span><span class="p">))</span>
        <span class="n">cur_point</span> <span class="o">=</span> <span class="n">next_point</span>

    <span class="n">edge_components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">component</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edge_components</span>


<span class="k">def</span> <span class="nf">_getUniqueEdges</span><span class="p">(</span><span class="n">all_edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the boundary of Delaunay represented by all_edges.</span>
<span class="sd">    Helper function for `getAlphaShapes`</span>

<span class="sd">    :param all_edges: np.array of shape (n,2) for n edges.</span>
<span class="sd">    :returns: np.array of shape (m,2) for m edges, where m &lt;= n.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">all_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">unique_edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_edges</span><span class="p">[</span><span class="n">counts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_pruneTouchingComponents</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given ring components, separate touching rings by extracting the smallest rings.</span>
<span class="sd">    Helper function for `_getOrderedEdgeComponents`</span>

<span class="sd">    :param edge_dict: a dict of edges. key is a point; value = set(its neighbors)</span>
<span class="sd">    :returns: tuple of (edge_dict with touching components pruned, list of touching components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">touching_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">point</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">touching_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cur_point</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">touching_points</span><span class="p">))</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">_bfsGetShortestRing</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">,</span> <span class="n">cur_point</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="n">edge_dict</span><span class="p">[</span><span class="n">component</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">edge_dict</span><span class="p">[</span><span class="n">component</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># separate loop to ensure all components are checked AFTER updating edge_dict</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">component</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">touching_points</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">component</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">touching_points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
    <span class="n">new_edge_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">point</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_edge_dict</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_edge_dict</span><span class="p">,</span> <span class="n">components</span>


<div class="viewcode-block" id="getAlphaShapes">
<a class="viewcode-back" href="../../../spatialcells.spatial.html#spatialcells.spatial._utils.getAlphaShapes">[docs]</a>
<span class="k">def</span> <span class="nf">getAlphaShapes</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the alpha shape of a set of points.</span>

<span class="sd">    :param points: np.array of shape (n,2) points.</span>
<span class="sd">    :param alpha: alpha value.</span>
<span class="sd">    :returns: set of (i,j) point pairs representing edges of the alpha-shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Need at least four points&quot;</span>

    <span class="c1"># triangulate all points</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="n">pa</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">pb</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span>
    <span class="c1"># Computing radius of triangle circumcircle</span>
    <span class="c1"># www.mathalino.com/reviewer/derivation-of-formulas/derivation-of-formula-for-radius-of-circumcircle</span>
    <span class="n">circum_r</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">area</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">circum_r</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">]</span>

    <span class="c1"># get edges that only appear once</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">_getUniqueEdges</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">verts</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">verts</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">verts</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># order all edges</span>
    <span class="n">edge_component_indices</span> <span class="o">=</span> <span class="n">_getOrderedEdgeComponents</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edge_component_indices:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_component_indices</span><span class="p">))</span>

    <span class="c1"># points</span>
    <span class="n">edge_components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">edge_component_indices</span><span class="p">:</span>
        <span class="n">edge_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">component</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edge_components</span></div>



<div class="viewcode-block" id="getComponents">
<a class="viewcode-back" href="../../../spatialcells.spatial.html#spatialcells.spatial._utils.getComponents">[docs]</a>
<span class="k">def</span> <span class="nf">getComponents</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">keep_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the components of a boundary defined by a MultiPolygon.</span>

<span class="sd">    :param boundary: the boundary to get components from</span>
<span class="sd">    :param keep_holes: whether to keep holes</span>
<span class="sd">    :returns: a list of components, where each component is a MultiPolygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">boundary</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keep_holes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">([</span><span class="n">geom</span><span class="p">])</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">([</span><span class="n">poly</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">components</span></div>



<div class="viewcode-block" id="getHoles">
<a class="viewcode-back" href="../../../spatialcells.spatial.html#spatialcells.spatial._utils.getHoles">[docs]</a>
<span class="k">def</span> <span class="nf">getHoles</span><span class="p">(</span><span class="n">boundary</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the holes within boundary components.</span>

<span class="sd">    :param boundary: the boundary to get holes from</span>
<span class="sd">    :returns: a list of holes, where each hole is a MultiPolygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">external_components</span> <span class="o">=</span> <span class="n">getComponents</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">keep_holes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">external_boundary</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">external_components</span><span class="p">)</span>
    <span class="n">holes_multi</span> <span class="o">=</span> <span class="n">external_boundary</span> <span class="o">-</span> <span class="n">boundary</span>
    <span class="k">if</span> <span class="n">holes_multi</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">:</span>
        <span class="n">holes_multi</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">([</span><span class="n">holes_multi</span><span class="p">])</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">getComponents</span><span class="p">(</span><span class="n">holes_multi</span><span class="p">,</span> <span class="n">keep_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">holes</span></div>



<div class="viewcode-block" id="pruneSmallComponents">
<a class="viewcode-back" href="../../../spatialcells.spatial.html#spatialcells.spatial._utils.pruneSmallComponents">[docs]</a>
<span class="k">def</span> <span class="nf">pruneSmallComponents</span><span class="p">(</span>
    <span class="n">boundary</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_edges</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">holes_min_area</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">holes_min_edges</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prune small components from a boundary defined by a MultiPolygon.</span>

<span class="sd">    :param boundary: the boundary to prune</span>
<span class="sd">    :param min_area: the minimum area of a polygon component to keep</span>
<span class="sd">    :param min_edges: the minimum number of edges of a polygon component to keep</span>
<span class="sd">    :param holes_min_area: the minimum area of a hole to keep the hole</span>
<span class="sd">    :param holes_min_edges: the minimum number of edges of a hole to keep the hole</span>
<span class="sd">    :returns: the pruned boundary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="n">boundary</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
        <span class="n">holes_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">interiors</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">Polygon</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;=</span> <span class="n">holes_min_area</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">holes_min_edges</span>
            <span class="p">):</span>
                <span class="n">holes_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;=</span> <span class="n">min_area</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">min_edges</span><span class="p">:</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">holes_to_keep</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span></div>



<span class="c1"># def getEdgesOnBoundaries(boundaries):</span>
<span class="c1">#     &quot;&quot;&quot; &quot;&quot;&quot;</span>
<span class="c1">#     points = []</span>
<span class="c1">#     for boundary_set in boundaries:</span>
<span class="c1">#         for compt in boundary_set:</span>
<span class="c1">#             points.append(compt)</span>
<span class="c1">#     return np.concatenate(points)</span>


<span class="c1"># def groupRemoveEdgeComponents(edge_components, nedges_min, nedges_out_min):</span>
<span class="c1">#     edge_components.sort(key=lambda x: len(x), reverse=True)</span>
<span class="c1">#     new_edge_components = []</span>
<span class="c1">#     for comp in edge_components:</span>
<span class="c1">#         is_in_comp = -1</span>
<span class="c1">#         for i, prev_comp in enumerate(new_edge_components):</span>
<span class="c1">#             # print(comp[0][0])</span>
<span class="c1">#             if isInRegion(comp[0][0], prev_comp[0]):</span>
<span class="c1">#                 is_in_comp = i</span>
<span class="c1">#                 # print(i, comp.shape)</span>
<span class="c1">#                 break</span>
<span class="c1">#         if is_in_comp != -1 and len(comp) &gt;= nedges_min:</span>
<span class="c1">#             new_edge_components[is_in_comp].append(comp)</span>
<span class="c1">#         elif is_in_comp == -1 and (len(comp) &gt;= nedges_out_min):</span>
<span class="c1">#             new_edge_components.append([comp])</span>
<span class="c1">#     return new_edge_components</span>

<span class="c1"># def isInRegion(point, boundary, debug=False):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Check whether &quot;point&quot; is within the boundary.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     count = 0</span>
<span class="c1">#     larger_y2_count = 0</span>
<span class="c1">#     smaller_y2_count = 0</span>

<span class="c1">#     # point = np.around(point, decimals=3)</span>
<span class="c1">#     point = np.array(point)</span>

<span class="c1">#     # print(point, point.shape, boundary, len(boundary))</span>
<span class="c1">#     for pi, pj in boundary:</span>
<span class="c1">#         # pi = np.around(pi, decimals=3)</span>
<span class="c1">#         # pj = np.around(pj, decimals=3)</span>

<span class="c1">#         # if point is on the edge points, return True</span>
<span class="c1">#         if (point[0] == pi[0] and point[1] == pi[1]) or (</span>
<span class="c1">#             point[0] == pj[0] and point[1] == pj[1]</span>
<span class="c1">#         ):</span>
<span class="c1">#             return True</span>

<span class="c1">#         # one of x values must be bigger than the point.x</span>
<span class="c1">#         # ignore other edges</span>
<span class="c1">#         if pi[0] &gt;= point[0] or pj[0] &gt;= point[0]:</span>
<span class="c1">#             cond1 = (pi[1] &gt;= point[1]) and (pj[1] &lt;= point[1])</span>
<span class="c1">#             cond2 = (pi[1] &lt;= point[1]) and (pj[1] &gt;= point[1])</span>
<span class="c1">#             if cond1 or cond2:</span>
<span class="c1">#                 # if debug: print(&quot;dealing&quot;, pi, pj)</span>

<span class="c1">#                 # if point and edge are on a horizantal line</span>
<span class="c1">#                 if (point[1] == pi[1]) and (point[1] == pj[1]):</span>
<span class="c1">#                     count += ret</span>

<span class="c1">#                 # handles edge case of touching line segments / segments on a straight line</span>
<span class="c1">#                 # if either x == point.x, let this point be x1.</span>
<span class="c1">#                 elif pi[1] == point[1] or pj[1] == point[1]:</span>
<span class="c1">#                     if debug:</span>
<span class="c1">#                         print(&quot;touching&quot;)</span>
<span class="c1">#                     if (pi[1] + pj[1]) / 2 &gt; point[1]:  # x2 larger</span>
<span class="c1">#                         larger_y2_count += 1</span>
<span class="c1">#                     elif (pi[1] + pj[1]) / 2 &lt; point[1]:  # x2 smaller</span>
<span class="c1">#                         smaller_y2_count += 1</span>

<span class="c1">#                 # # check if line segment intersects with point, (0, point.y). if so count += 1</span>
<span class="c1">#                 # # only check if the line segment is on the left side of the point and point between the two y values</span>
<span class="c1">#                 # if (pi[1] &lt; point[1]) != (pj[1] &lt; point[1]) and (pi[0] &lt; point[0] or pj[0] &lt; point[0]):</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     ret = isIntersect(point, (max(pi[0], pj[0]), point[1]), pi, pj)</span>
<span class="c1">#                     if debug:</span>
<span class="c1">#                         print(&quot;isIntersect&quot;, ret, pi, pj)</span>
<span class="c1">#                     # if debug:print(point, (0, point[1]))</span>
<span class="c1">#                     # if debug:print(pi, pj)</span>
<span class="c1">#                     count += ret</span>

<span class="c1">#     # if debug: print(&quot;before:&quot;, count)</span>
<span class="c1">#     count += (larger_y2_count % 2) and (smaller_y2_count % 2)</span>
<span class="c1">#     if debug:</span>
<span class="c1">#         print(</span>
<span class="c1">#             &quot;count:&quot;,</span>
<span class="c1">#             count,</span>
<span class="c1">#             &quot;larger_y2_count&quot;,</span>
<span class="c1">#             larger_y2_count,</span>
<span class="c1">#             &quot;smaller_y2_count&quot;,</span>
<span class="c1">#             smaller_y2_count,</span>
<span class="c1">#         )</span>

<span class="c1">#     return (count % 2) != 0</span>


<span class="c1"># def getPolygons(boundaries):</span>
<span class="c1">#     polygons = []</span>
<span class="c1">#     for boundary_set in boundaries:</span>
<span class="c1">#         external_boundaries = set(np.arange(len(boundary_set)))</span>
<span class="c1">#         internal_boundaries = defaultdict(list)</span>
<span class="c1">#         for i in range(len(boundary_set)):</span>
<span class="c1">#             for j in range(i + 1, len(boundary_set)):</span>
<span class="c1">#                 pointi = boundary_set[i][:, 0, :]</span>
<span class="c1">#                 pointj = boundary_set[j][:, 0, :]</span>
<span class="c1">#                 polygoni = Polygon(pointi)</span>
<span class="c1">#                 polygonj = Polygon(pointj)</span>
<span class="c1">#                 if polygoni.contains(polygonj):</span>
<span class="c1">#                     internal_boundaries[i].append(pointj)</span>
<span class="c1">#                     external_boundaries.discard(j)</span>
<span class="c1">#                 elif polygonj.contains(polygoni):</span>
<span class="c1">#                     internal_boundaries[j].append(pointi)</span>
<span class="c1">#                     external_boundaries.discard(i)</span>
<span class="c1">#         for external_boundary_idx in external_boundaries:</span>
<span class="c1">#             outer_points = boundary_set[external_boundary_idx][:, 0, :]</span>
<span class="c1">#             inner_points = internal_boundaries[external_boundary_idx]</span>
<span class="c1">#             polygon = Polygon(outer_points, inner_points)</span>
<span class="c1">#             polygons.append(polygon)</span>
<span class="c1">#     return polygons</span>


<span class="c1"># def isCounterClockwise(A, B, C):</span>
<span class="c1">#     # if ABC is counterclockwise, then slope of AB less than AC</span>
<span class="c1">#     return (C[1] - A[1]) * (B[0] - A[0]) &gt; (B[1] - A[1]) * (C[0] - A[0])</span>


<span class="c1"># def isIntersect(p1, p2, p3, p4):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Checkswhether the line segment p1-p2 intersects with p3-p4,</span>
<span class="c1">#     assuming no colinear points</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     return isCounterClockwise(p1, p3, p4) != isCounterClockwise(</span>
<span class="c1">#         p2, p3, p4</span>
<span class="c1">#     ) and isCounterClockwise(p1, p2, p3) != isCounterClockwise(p1, p2, p4)</span>


<span class="c1"># def PointsInCircum(eachPoint, r, n=100):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Return n points within r distance from eachPoint</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     return [</span>
<span class="c1">#         (</span>
<span class="c1">#             eachPoint[0] + math.cos(2 * math.pi / n * x) * r,</span>
<span class="c1">#             eachPoint[1] + math.sin(2 * math.pi / n * x) * r,</span>
<span class="c1">#         )</span>
<span class="c1">#         for x in range(0, n + 1)</span>
<span class="c1">#     ]</span>


<span class="c1"># def bufferPoints(inPoints, stretchCoef, n=100):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Return n*len(inPoints) points that are within r distance of each point.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     newPoints = []</span>
<span class="c1">#     for eachPoint in inPoints:</span>
<span class="c1">#         newPoints += PointsInCircum(eachPoint, stretchCoef, n)</span>
<span class="c1">#         # newPoints.append(np.array(PointsInCircum(eachPoint, stretchCoef, n)))</span>
<span class="c1">#     newPoints = np.array(newPoints)</span>

<span class="c1">#     return newPoints</span>


<span class="c1"># def hasEdge(point, step, polygons):</span>
<span class="c1">#     grid_edges = Polygon(</span>
<span class="c1">#         [</span>
<span class="c1">#             (point[0], point[1]),</span>
<span class="c1">#             (point[0] + step, point[1]),</span>
<span class="c1">#             (point[0], point[1] + step),</span>
<span class="c1">#             (point[0] + step, point[1] + step),</span>
<span class="c1">#         ]</span>
<span class="c1">#     ).boundary</span>
<span class="c1">#     for polygon in polygons:</span>
<span class="c1">#         if polygon.boundary.intersects(grid_edges):</span>
<span class="c1">#             return True</span>
<span class="c1">#     return False</span>


<span class="c1"># def getBufferedBoundary(boundaries, offset=200, minsize=20):</span>
<span class="c1">#     &quot;&quot;&quot; &quot;&quot;&quot;</span>

<span class="c1">#     buffered_boundaries = []</span>
<span class="c1">#     outer_multipolygon = Polygon()</span>
<span class="c1">#     inner_multipolygon = Polygon()</span>
<span class="c1">#     for boundary_set in boundaries:</span>
<span class="c1">#         for i, boundary in enumerate(boundary_set):</span>
<span class="c1">#             boundary_points = boundary[:, 0, :]</span>
<span class="c1">#             boundary_polygon = Polygon(boundary_points)</span>
<span class="c1">#             if i == 0:</span>
<span class="c1">#                 outer_multipolygon = outer_multipolygon | boundary_polygon.buffer(</span>
<span class="c1">#                     offset</span>
<span class="c1">#                 )</span>
<span class="c1">#             else:</span>
<span class="c1">#                 inner_multipolygon = inner_multipolygon | boundary_polygon.buffer(</span>
<span class="c1">#                     -offset</span>
<span class="c1">#                 )</span>

<span class="c1">#     s_boundary_polygons = outer_multipolygon - inner_multipolygon</span>

<span class="c1">#     if isinstance(s_boundary_polygons, MultiPolygon):</span>
<span class="c1">#         s_boundary_polygons = s_boundary_polygons.geoms</span>
<span class="c1">#     else:</span>
<span class="c1">#         s_boundary_polygons = [s_boundary_polygons]</span>

<span class="c1">#     for s_boundary_polygon in s_boundary_polygons:</span>
<span class="c1">#         for ring in [s_boundary_polygon.exterior] + list(s_boundary_polygon.interiors):</span>
<span class="c1">#             buffered_points = np.array(ring.coords)</span>
<span class="c1">#             if buffered_points.shape[0] &lt; minsize:</span>
<span class="c1">#                 continue</span>
<span class="c1">#             buffered_edges = np.stack(</span>
<span class="c1">#                 [np.roll(buffered_points, -1, axis=0), buffered_points], axis=1</span>
<span class="c1">#             )</span>
<span class="c1">#             buffered_boundaries.append(buffered_edges)</span>

<span class="c1">#     # comp_polygons = getPolygons([buffered_boundaries])</span>

<span class="c1">#     # return [buffered_boundaries], comp_polygons</span>

<span class="c1">#     buffered_boundaries_edge = getEdgesOnBoundaries([buffered_boundaries])</span>
<span class="c1">#     return buffered_boundaries_edge, [buffered_boundaries]</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SpatialCells</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spatialcells.html">Functions Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Guihong Wan; Zoltan Maliga & Boshen Yan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>